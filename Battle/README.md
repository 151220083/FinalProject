### 思路
##### 可以将葫芦娃大战妖精这个问题分为前端的UI界面显示、后端的数据操纵以及前后端交互。  
##### 前端的UI界面使用javaFX来完成，数据操作主要是用Square记录二维空间的详细数据、用Creature来表示战斗中的每个生物（包括葫芦娃、爷爷、蝎子精、蛇精、小妖怪）  
### 具体实现
#### UI界面
    使用flowPane来对scene进行绘制，没有生物站在对应位置的时候为透明图像。窗口大小不可变。  
    
#### Creature类  
    Creature类继承自Runnable，拥有成员变量Member。     
    Member是一个枚举对象，将生物个体与其对应的图像联系了起来。   
	在使用Creature类时，静态函数prepare()中创建了多个Creature线程，等待从UI界面接收到指令使得战斗开始。  
	
####Square类
    Square类用来记录战斗空间的人物分布。。
    Square类中的二维数组members存储了当前NxM的二维空间中，Member的分布。
          此处Member可重复，主要是小妖怪可重复。
    
#### 交互
	为了保证线程之间不互相冲突，使用了synchronized()函数来对对应代码段上锁
	具体操作如下：
		synchronized(Creature.class) {...}
	
### 运行
#### 准备阶段
    javaFX的stage搭建完成并show成功，所有线程创造完毕   
    UI界面成功显示，双方排着阵列等待战斗开始

#### 战斗阶段
	当战斗之后开始每一个生物首先寻找四周是否有可攻击对象（此处的可攻击对象指的是不同势力的生物）
	即对于每一个Creature线程，首先尝试attack()寻找四周与自己Force不同的存在，再进行攻击。
	若没有可攻击对象，Creature寻找合适的路径来进行移动
### 结束方式
	若有一方全部阵亡则另一方胜利。
	
###问题
	寻找路径的算法较为简陋，因此在尸体存在的情况下可能会出现无法出现胜负、持续进行战争的情况。